
import numpy as np 
x=np.array([0,0],[0,1],[1,0],[1,1])
y=np.array([0,1,1,0])
class perceptron(object):
        def __init__(self, eta=0.01, n_iter=10):
            self.eta = eta
            self.n_iter = n_iter
            self.rbf_x=[]
            
        def fit(self,X,y):
            c1=np.array([0,0])
            c2=np.array([1,1])
            for i in range(X.shape[0]):
                temp=[]
                temp.append(np.exp(-((X[i][0]-c1[0])+(X[i][1]-c1[1]))**2))
                temp.append(np.exp(-((X[i][0]-c2[0])+(X[i][1]-c2[1]))**2))
                self.rbf_x.append(temp)
                x=np.array(self.rrbf_x)
                print(X)
                self.w_ = np.zeros(1+X.shape[1])
                
                for _ in range(self.n_iter):
                    
                    for xi,target in zip(X,y):
                        error=target-self.predict1(xi)
                        if error!=0:
                            update = self.eta+error
                            self.w_[1:] +=update * xi
                            self.w_[0] +=update
                            
                return self
            def net_input(slef,X):
                """calculate net input"""
                return np.dot(X,self.w_[1:]) + self.w_[0]
            def predict1(self,x):
                """return class label after unit step"""
